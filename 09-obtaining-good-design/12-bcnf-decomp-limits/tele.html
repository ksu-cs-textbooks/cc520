<!DOCTYPE html>

<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article" data-r-output-format="html">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.148.1">
    <meta name="generator" content="Relearn 8.0.0">
    <meta name="description" content="YouTube Video Video Transcription Welcome back everyone. In this video, we’re going to be taking a look at some limitations behind decomposition using Boyce Codd Normal Form. So previously, we talked about how we, when we’re decomposing our tables, we need to be careful because if we’re not actually adhering to Boyce Codd Normal Form, and we’re decomposing our tables, ad hoc Li, we could actually have lossy decomposition, meaning we actually lose the original information, or at least, we lose, we don’t lose rows of data. But we can’t we can’t actually reconnect those rows of data together. So our joins become useless there. But there are some limitations behind Boyce Codd Normal Form. So Boyce Codd, normal form by itself and we’re decomposing according to it. Our decompositions are always lost less, which is a good thing, which is a good thing. But what about functional dependencies? So if we have this relation here, Professor projects departments, where we have our functional dependencies, Professor implies department and projects department implies professor. This is a Boyce Codd Normal Form violation because we do have a functional dependency. That is not a super key. Okay, so we want to decompose this. And so we have Professor departments, Professor department, and then we’ll have everything else, right, Professor department and everything else. So that’s Professor department, and we have Professor project. But what about this functional dependency here, Project department implies professor.">
    <meta name="author" content="Josh Weese">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Limitations of BCNF Decomposition :: CC 520 Textbook">
    <meta name="twitter:description" content="YouTube Video Video Transcription Welcome back everyone. In this video, we’re going to be taking a look at some limitations behind decomposition using Boyce Codd Normal Form. So previously, we talked about how we, when we’re decomposing our tables, we need to be careful because if we’re not actually adhering to Boyce Codd Normal Form, and we’re decomposing our tables, ad hoc Li, we could actually have lossy decomposition, meaning we actually lose the original information, or at least, we lose, we don’t lose rows of data. But we can’t we can’t actually reconnect those rows of data together. So our joins become useless there. But there are some limitations behind Boyce Codd Normal Form. So Boyce Codd, normal form by itself and we’re decomposing according to it. Our decompositions are always lost less, which is a good thing, which is a good thing. But what about functional dependencies? So if we have this relation here, Professor projects departments, where we have our functional dependencies, Professor implies department and projects department implies professor. This is a Boyce Codd Normal Form violation because we do have a functional dependency. That is not a super key. Okay, so we want to decompose this. And so we have Professor departments, Professor department, and then we’ll have everything else, right, Professor department and everything else. So that’s Professor department, and we have Professor project. But what about this functional dependency here, Project department implies professor.">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cc520/09-obtaining-good-design/12-bcnf-decomp-limits/">
    <meta property="og:site_name" content="CC 520 Textbook">
    <meta property="og:title" content="Limitations of BCNF Decomposition :: CC 520 Textbook">
    <meta property="og:description" content="YouTube Video Video Transcription Welcome back everyone. In this video, we’re going to be taking a look at some limitations behind decomposition using Boyce Codd Normal Form. So previously, we talked about how we, when we’re decomposing our tables, we need to be careful because if we’re not actually adhering to Boyce Codd Normal Form, and we’re decomposing our tables, ad hoc Li, we could actually have lossy decomposition, meaning we actually lose the original information, or at least, we lose, we don’t lose rows of data. But we can’t we can’t actually reconnect those rows of data together. So our joins become useless there. But there are some limitations behind Boyce Codd Normal Form. So Boyce Codd, normal form by itself and we’re decomposing according to it. Our decompositions are always lost less, which is a good thing, which is a good thing. But what about functional dependencies? So if we have this relation here, Professor projects departments, where we have our functional dependencies, Professor implies department and projects department implies professor. This is a Boyce Codd Normal Form violation because we do have a functional dependency. That is not a super key. Okay, so we want to decompose this. And so we have Professor departments, Professor department, and then we’ll have everything else, right, Professor department and everything else. So that’s Professor department, and we have Professor project. But what about this functional dependency here, Project department implies professor.">
    <meta property="og:locale" content="en_us">
    <meta property="og:type" content="article">
    <meta property="article:section" content="Obtaining Good Design">
    <meta property="article:modified_time" content="2026-01-22T10:00:41-06:00">
    <meta itemprop="name" content="Limitations of BCNF Decomposition :: CC 520 Textbook">
    <meta itemprop="description" content="YouTube Video Video Transcription Welcome back everyone. In this video, we’re going to be taking a look at some limitations behind decomposition using Boyce Codd Normal Form. So previously, we talked about how we, when we’re decomposing our tables, we need to be careful because if we’re not actually adhering to Boyce Codd Normal Form, and we’re decomposing our tables, ad hoc Li, we could actually have lossy decomposition, meaning we actually lose the original information, or at least, we lose, we don’t lose rows of data. But we can’t we can’t actually reconnect those rows of data together. So our joins become useless there. But there are some limitations behind Boyce Codd Normal Form. So Boyce Codd, normal form by itself and we’re decomposing according to it. Our decompositions are always lost less, which is a good thing, which is a good thing. But what about functional dependencies? So if we have this relation here, Professor projects departments, where we have our functional dependencies, Professor implies department and projects department implies professor. This is a Boyce Codd Normal Form violation because we do have a functional dependency. That is not a super key. Okay, so we want to decompose this. And so we have Professor departments, Professor department, and then we’ll have everything else, right, Professor department and everything else. So that’s Professor department, and we have Professor project. But what about this functional dependency here, Project department implies professor.">
    <meta itemprop="dateModified" content="2026-01-22T10:00:41-06:00">
    <meta itemprop="wordCount" content="1017">
    <title>Limitations of BCNF Decomposition :: CC 520 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cc520/09-obtaining-good-design/12-bcnf-decomp-limits/" rel="canonical" type="text/html" title="Limitations of BCNF Decomposition :: CC 520 Textbook">
    <link href="/cc520/09-obtaining-good-design/12-bcnf-decomp-limits/index.xml" rel="alternate" type="application/rss+xml" title="Limitations of BCNF Decomposition :: CC 520 Textbook">
    <link href="/cc520/09-obtaining-good-design/12-bcnf-decomp-limits/index.print.html" rel="alternate" type="text/html" title="Limitations of BCNF Decomposition :: CC 520 Textbook">
    <link href="/cc520/09-obtaining-good-design/12-bcnf-decomp-limits/embed.html" rel="alternate" type="text/html" title="Limitations of BCNF Decomposition :: CC 520 Textbook">
    <link href="/cc520/css/auto-complete/auto-complete.min.css?1770736615" rel="stylesheet">
    <script src="/cc520/js/auto-complete/auto-complete.min.js?1770736615" defer></script>
    <script src="/cc520/js/search-lunr.min.js?1770736615" defer></script>
    <script src="/cc520/js/search.min.js?1770736615" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.index_js_url="/cc520/searchindex.en.js?1770736615";
    </script>
    <script src="/cc520/js/lunr/lunr.min.js?1770736615" defer></script>
    <script src="/cc520/js/lunr/lunr.stemmer.support.min.js?1770736615" defer></script>
    <script src="/cc520/js/lunr/lunr.multi.min.js?1770736615" defer></script>
    <script src="/cc520/js/lunr/lunr.en.min.js?1770736615" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.contentLangs=['en'];
    </script>
    <link href="/cc520/fonts/fontawesome/css/fontawesome-all.min.css?1770736615" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc520/fonts/fontawesome/css/fontawesome-all.min.css?1770736615" rel="stylesheet"></noscript>
    <link href="/cc520/css/perfect-scrollbar/perfect-scrollbar.min.css?1770736615" rel="stylesheet">
    <link href="/cc520/css/theme.min.css?1770736615" rel="stylesheet">
    <link href="/cc520/css/format-html.min.css?1770736615" rel="stylesheet" id="R-format-style">
    <script>
      window.relearn = window.relearn || {};
      // configuration
      window.relearn.min = `.min`;
      window.relearn.path='\/09-obtaining-good-design\/12-bcnf-decomp-limits\/';
      window.relearn.relBasePath='..\/..';
      window.relearn.relBaseUri='..\/..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cc520';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.relearn.disableInlineCopyToClipboard=true;
      window.relearn.enableBlockCodeWrap=false;
      // legal
      window.relearn.getItem = (s,n) => {return s.getItem(n)};
      window.relearn.setItem = (s,n,v) => {return s.setItem(n,v)};
      window.relearn.removeItem = (s,n) => {return s.removeItem(n)};
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
      // variant stuff
      window.relearn.themevariants = [ 'light-theme' ];
      window.relearn.customvariantname = "my-custom-variant";
      // [x] russfeld
      window.relearn.writeVariant=false;
      window.relearn.changeVariant = function(variant) {
        var oldVariant = document.documentElement.dataset.rThemeVariant;
        window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        document.documentElement.dataset.rThemeVariant = variant;
        if (oldVariant != variant) {
          document.dispatchEvent( new CustomEvent('themeVariantLoaded', { detail: { variant, oldVariant } }) );
          window.relearn.markVariant();
        }
      }
      window.relearn.markVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant");
        document.querySelectorAll(".R-variantswitcher select").forEach((select) => {select.value = variant;});
      }
      window.relearn.initVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant") ?? "";
        if( variant == window.relearn.customvariantname ){
        }else if( !variant || !window.relearn.themevariants.includes(variant) ){
          variant = window.relearn.themevariants[0];
          
          if (window.relearn.writeVariant) {
            window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
          }
        }
        document.documentElement.dataset.rThemeVariant = variant;
      }
      window.relearn.initVariant();
      window.relearn.markVariant();
    </script>
    <link href="/cc520/css/custom.css?1770736615" rel="stylesheet">
  </head>
  <body class="mobile-support html" data-url="/cc520/09-obtaining-good-design/12-bcnf-decomp-limits/">
    
    <div id="tele" class="tele mirror">
    
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      
      
      
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable 09-obtaining-good-design" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
  </header>

<h1 id="limitations-of-bcnf-decomposition">Limitations of BCNF Decomposition</h1>


<a href="https://www.youtube.com/watch?v=NvMeVgT_eU4">YouTube Video</a>

<h2 id="video-transcription">Video Transcription</h2>
<p>Welcome back everyone. In this video, we&rsquo;re going to be taking a look at some limitations behind decomposition using Boyce Codd Normal Form. So previously, we talked about how we, when we&rsquo;re decomposing our tables, we need to be careful because if we&rsquo;re not actually adhering to Boyce Codd Normal Form, and we&rsquo;re decomposing our tables, ad hoc Li, we could actually have lossy decomposition, meaning we actually lose the original information, or at least, we lose, we don&rsquo;t lose rows of data. But we can&rsquo;t we can&rsquo;t actually reconnect those rows of data together. So our joins become useless there. But there are some limitations behind Boyce Codd Normal Form. So Boyce Codd, normal form by itself and we&rsquo;re decomposing according to it. Our decompositions are always lost less, which is a good thing, which is a good thing. But what about functional dependencies? So if we have this relation here, Professor projects departments, where we have our functional dependencies, Professor implies department and projects department implies professor. This is a Boyce Codd Normal Form violation because we do have a functional dependency. That is not a super key. Okay, so we want to decompose this. And so we have Professor departments, Professor department, and then we&rsquo;ll have everything else, right, Professor department and everything else. So that&rsquo;s Professor department, and we have Professor project. But what about this functional dependency here, Project department implies professor.</p>
<p>So this has no functional dependencies. But we lose that dependency, right? We lose this functional dependency project department no longer implies. Professor, right? Project department no longer implies professor. So this is a issue right? Or this is a problem with Boyce Codd Normal Form more of a limitation, right? We still don&rsquo;t lose information, we still don&rsquo;t lose information, we can actually join this back together and get our original table back. So what&rsquo;s the general problem here? Right, what&rsquo;s the general problem? Well, what about this right, what about this set of data? Right? We have Professor department Professor project, and we have Johnson COEs Robinson CIS Johnson recruitment, Robinson recruitment. So no problem here, right? Because our functional dependencies, local to the individual tables are satisfied, right? That&rsquo;s fine. But if we pull all the data back into a single table again, ah, Project department implies Professor no longer actually holds, right? Because we have CDs recruitment, CDs, recruitment, and now no longer implies professor. Right, that no longer applies. Professor. So this is either a bad functional dependency, or we can try to attempt juice do more with our decompositions. How do we keep hold of those functional B? How do we keep a hold of those functional dependencies when we decompose our tables? So let&rsquo;s take a look at how we might do this. So we lose dependencies, when in relation with a dependency x implies y is decomposed, And x ends up in one of the new relations and y ends up only and another. So if a functional dependency is split apart, we lose that functional dependency.</p>
<p>So that decomposition is we refer to it as not dependency preserving, it is lost less, but it is not dependency preserving. So the common form of this issue is a b implies c and c implies b Right? So remember our example. We had Professor implies department, and project department implies professor. So A, B implies c, and c implies B. So this is our limitation, right? This is our limitation with Boyce Codd Normal Form. Boyce Codd. Normal Form decomposition does not always preserve dependencies. Let&rsquo;s take a look at this example. This is an example that I previously broke down using decompose using Closure sets. But if we attach I&rsquo;m not going to go over the actual decompose Part, feel free to track, go down the tree here and follow this if you&rsquo;d like. But this was decomposers enclosure sets. And so let&rsquo;s take a look at our functional dependencies now, as a result, so we have, we have d implies a, so that holds that holds, we have c implies d, that still holds, we have f implies B, and that holds. But this functional dependency here, a b implies C, no longer holds. So again, another example of how Boyce Codd Normal form of decomposition may not keep all of your functional dependencies intact, it may not keep all of your functional dependencies intact. So, general goals here, why are we decomposing them? Right? Why are we decomposing them? If we lose functional dependencies as part of it? Well, big goal that we want to target here is eliminating anomalies, right anomalies. reduce redundancy, right? When we update and delete data, right? We don&rsquo;t want to have to update and delete in multiple parts. Because that leads to inconsistency with data.</p>
<p>That is the big problem that we&rsquo;re trying to solve here. Eliminate anomalies. We want to also be able to recover information when we decompose, right when we decompose a relation. We don&rsquo;t want to lose data as results. So can we get the original one back? That&rsquo;s good. But preservation of dependencies, can we enforce functional dependencies without performing joints? Right? Can we achieve this without performing joints? That is our general goals when we try to decompose our tables and there are ways that we can decompose typically if we choose to decompose into a specific or two particular groups of attributes to hold on to those functional dependencies. So generally speaking here, right, Boyce Codd, normal form decomposition, no anomalies. Awesome. Good green thumbs up there. recoverability of information. Also a good big thumbs up there as well. But unfortunately, sometimes we may lose dependencies as a result. So we can get most we can hit most of our goals, right? We can hit most of our goals with Boyce Codd Normal Form decomposition. And sometimes if we have multiple ways of being able to decompose that relation, sometimes we can hold on to those dependencies, but not always right. Not always</p>

  <footer class="footline">
  </footer>
</article>
        </div>
      </main>
      
      
      
    </div>
    <script>
      window.MathJax = Object.assign( window.MathJax || {}, {
        tex: {
          inlineMath:  [['\\(', '\\)'], ['$',  '$']],  
          displayMath: [['\\[', '\\]'], ['$$', '$$']], 
        },
        options: {
          enableMenu: false 
        }
      }, JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="/cc520/js/mathjax/tex-mml-chtml.js?1770736615"></script>
    <script src="/cc520/js/clipboard/clipboard.min.js?1770736615" defer></script>
    <script src="/cc520/js/perfect-scrollbar/perfect-scrollbar.min.js?1770736615" defer></script>
    <script src="/cc520/js/theme.min.js?1770736615" defer></script>
      
      
      
    </div> 
  <script src="/cc520/js/tele-scroll.min.js?1770736615" defer></script>
  </body>
</html>
